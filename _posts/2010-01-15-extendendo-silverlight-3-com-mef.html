---
layout: blogger
title: Criando aplicações extensíveis em Silverlight 3 com MEF
date: 2010-01-15T21:32:00.0000000-02:00
permalink: /:year/:month/:slug:output_ext
tags: [Silverlight 3, Tutorial, MEF, Silverlight]
---
<p>Atualmente estou trabalhando em um projeto, em Silverlight 3, cuja principal característica é que será uma aplicação extensível. Isso significa que depois que a aplicação for publicada deverá ser possível escrever e instalar extensões facilmente, sem que seja necessário mexer no código da aplicação principal. Existem várias formas de atingir esse objetivo e vários padrões de desenvolvimento que podem ser utilizados para ajudar a realizar essa tarefa com mais facilidade. Neste post vou demonstrar como fazer isso utilizando o MEF – Managed Extensibility Framework, que ao meu ver é a forma mais eficiente e segura de tornar sua aplicação extensível.</p>  <h4>Mas o que é exatamente o MEF?</h4>  <p>MEF é um framework open source que está sendo desenvolvido já há algum tempo pela Microsoft, cujo objetivo é tornar a tarefa de criar aplicações extensíveis o mais simples possível. O código fonte pode assim com a última versão do MEF podem ser encontrados no Codeplex em <a href="http://mef.codeplex.com">http://mef.codeplex.com</a>. Os códigos fonte e binários do MEF presentes no Codeplex são para o .NET Framework 3.5 e Silverlight 3. O MEF já faz parte do SDK do Silverlight 4, então não é necessário fazer nenhuma instalação extra (além do Silverlight 4 Tools para Visual Studio ou pelo menos o próprio Silverlight 4 SDK).</p>  <h4>Por que utilizar o MEF?</h4>  <p>Essa aplicação na qual estou trabalhando começou a ser concebida aproximadamente em Julho de 2009. Na época eu já havia ouvido falar do MEF mas ainda não fazia idéia do que realmente era e como ele poderia me ajudar. Além disso eu não tinha visto nada ainda sobre MEF e Silveright. </p>  <p>A aplicação tem como base o uso de serviços. Ela tem alguns serviços padrão implementados nativamente mas também oferece interfaces que podem ser implementadas por terceiros que estejam interessados em disponibilizar seus próprios serviços na aplicação. Minha idéia inicial era fazer a implementação toda manualmente, ou seja, eu teria que:</p>  <ul>   <li>escrever todo o código responsável por baixar/ler o zip contendo a extensão, </li>    <li>ler um arquivo de manifesto que estaria listando todas as extensões disponíveis naquele pacote, </li>    <li>instanciar cada extensão e adicioná-la nas coleções internas da aplicação </li> </ul>  <p>Comecei a fazer uma prova de conceito e vi que tudo isso era possível de ser feito mas não era uma tarefa trivial. Havia bastante código a ser escrito e muitas situações a ser levadas em consideração. </p>  <p>Decidimos começar fazendo uma aplicação como prova de conceito sem a funcionalidade de extensibilidade e depois eu me preocuparia com isso. O tempo passou, a POC foi feita e foi um sucesso.</p>  <p>A questão de extensibilidade ainda me incomodava. Eu não queria ter todo aquele trabalho pois parecia que eu estava reinventado a roda. Era final de Outubro e o PDC havia terminado. Enquanto vasculhava as sessions que eu queria baixar para assistir vi uma que me interessou chamada <a title="Tradução : Criando aplicações ricas de internet com MEF" href="http://microsoftpdc.com/Sessions/FT24" rel="external">Building Extensible Rich Internet Applications with the Managed Extensibility Framework</a>. Fiz o download, assisti e no mesmo instante fiquei convencido de que seria assim que eu implementaria a extensibilidade da minha aplicação. Com aproximadamente 5 linhas de código e 2 referencias dava pra fazer 80% da funcionalidade que eu precisava!</p>  <h4>Chega de blá, blá, blá, me mostra logo como funciona!</h4>  <p>Chegamos no presente. Voltei a trabalhar naquela aplicação, só que que agora não é mais uma prova de conceito. Como o Silverlight 4 ainda não tem licença Go-Live a aplicação está sendo feita em Silverlight 3 mas já pensando em ser migrada para Silverlight 4 assim que for possível. Tudo que será mostrado aqui serve para Silverlight 3 e Silverlight 4. </p>  <p>Para utilizar o MEF é necessário fazer referência a 2 dlls (presentes no Codeplex) : </p>  <ul>   <li>System.ComponentModel.Composition </li>    <li>System.ComponentModel.Composition.Initialization </li> </ul>  <p>O MEF funciona da seguinte forma: Você cria uma interface ou classe base e a marca com um atributo do MEF que indica que ela é uma extensão (chamada pelo MEF de Export). Essa interface será o seu contrato. Depois você cria classes que implementam o seu contrato (esses serão os seus serviços que serão exportados). Depois você cria uma propriedade (array ou collection) que conterá a sua coleção de serviços e marca essa propriedade com um atributo do MEF que indica que ele deve colocar alí as extensões apropriadas que ele achar (o MEF chama isso de Import). Depois basta chamar uma linha de código que diz ao MEF “preencha todos os Imports do meu objeto”. Parece meio confuso explicando assim então é melhor eu mostrar.</p>  <p>Criei uma solution de exemplo (o link para download está no final do post) contendo 5 projetos. </p>  <p><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="Solution no Visual Studio 2010" border="0" alt="Solution no Visual Studio 2010" src="http://lh4.ggpht.com/_33jXBude3Pw/S1IGpjADKgI/AAAAAAAAApo/JPVaoyS5aJ8/image%5B14%5D.png?imgmax=800" width="391" height="216" /> </p>  <ul>   <li><strong>MEF.Extension</strong> : Contém uma extensão para a aplicação. É um exemplo do que será feito por terceiros e parceiros. </li>    <li><strong>MEF.Lib</strong> : É a biblioteca core da aplicação. Contém a interface de contrato do serviço e 1 implementação nativa. </li>    <li><strong>MEF.Tests</strong> : É a aplicação principal. Contém outras 2 implementações do serviço e todo o resto da lógica da aplicação. </li>    <li><strong>MEF.Tests.Web</strong> : Web application utilizado para testar e depurar a aplicação. </li>    <li><strong>System.ComponentModel.Composition.Packaging.Toolkit</strong> : Recompilação em Silverlight 3 de uma dll que só existe no SDK do Silverlight 4. Explicarei melhor mais adiante. </li> </ul>  <p>O projeto MEF.Lib faz referência a <strong>System.ComponentModel.Composition.</strong> </p>  <p><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="Referência do MEF.Lib" border="0" alt="Referência do MEF.Lib" src="http://lh5.ggpht.com/_33jXBude3Pw/S1IGqZs9fmI/AAAAAAAAAps/TxLfJE98nAw/image%5B29%5D.png?imgmax=800" width="319" height="260" /></p>  <p>No projeto MEF.Lib temos a interface IServico que foi marcada com o atributo <strong>InheritedExport</strong>. Esse atributo serve para dizer que qualquer classe que implementar essa interface será automáticamente considerada pelo MEF como um Export.</p>  <p><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="interface IServico" border="0" alt="interface IServico" src="http://lh6.ggpht.com/_33jXBude3Pw/S1IGq-J0DeI/AAAAAAAAApw/8tp6mYQK38A/image%5B20%5D.png?imgmax=800" width="401" height="179" /> </p>  <p>Temos também uma classe chamada ServicoRoot que é uma implementação de IServico.</p>  <p><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="classe ServicoRoot" border="0" alt="classe ServicoRoot" src="http://lh5.ggpht.com/_33jXBude3Pw/S1IGrRet9OI/AAAAAAAAAp0/FPpht0azYRs/image%5B23%5D.png?imgmax=800" width="405" height="217" /> </p>  <p>O projeto MEF.Tests faz referência ao projeto MEF.Lib, às duas dlls do MEF e à dll de Packaging de MEF do Toolkit que foi recompilada e adicionada nessa solution. Temos também outras 2 implementações de IServico, chamadas ServicoA e ServicoB, implementadas exatamente da mesma forma que ServicoRoot.</p>  <p><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="Referencias do projeto MEF.Tests" border="0" alt="Referencias do projeto MEF.Tests" src="http://lh3.ggpht.com/_33jXBude3Pw/S1IGsC4oVhI/AAAAAAAAAp4/qzpiYd-KShg/image%5B32%5D.png?imgmax=800" width="415" height="385" /> </p>  <p>Temos uma página principal chamada MainPage que contém apenas um botão e um listbox. A aplicação está implementada utilizando o padrão MVVM, então temos uma classe que é o ViewModel de MainPage. Nessa classe há uma propriedade chamada “Servicos” que será onde o MEF irá colocar todas as implementações que ele achar de IServico. </p>  <p><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="Classe MainPageViewModel" border="0" alt="Classe MainPageViewModel" src="http://lh3.ggpht.com/_33jXBude3Pw/S1IGsiB2p2I/AAAAAAAAAp8/EXj4kgwKajw/image%5B35%5D.png?imgmax=800" width="563" height="307" /> </p>  <p>Na linha 9 do ViewModel podemos ver uma chamada ao “<font face="Courier New">PartInitializer.SatisfyImports(this);</font>” O que isso faz é avaliar a classe atual e procurar por todas as propriedades marcadas com o atributo Import ou ImportMany. Depois ela procura no seu catalogo por todas as classes marcadas como Export que satisfaçam os Imports solicitados, instancia cada uma dessas classes e preenche as propriedades dos Imports. </p>  <p>Na tela há um ListBox fazendo binding com a propriedade Servicos do ViewModel. Se executarmos a aplicação como está aparecerão 3 serviços no ListBox, como pode ser visto abaixo:</p>  <p><a href="http://lh3.ggpht.com/_33jXBude3Pw/S1IGtyyhFxI/AAAAAAAAAqA/h6-97BBPj6Y/s1600-h/image%5B62%5D.png" target="_blank"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="Aplicação rodando com extensões internas" border="0" alt="Aplicação rodando com extensões internas" src="http://lh6.ggpht.com/_33jXBude3Pw/S1IGwwa021I/AAAAAAAAAqE/BSoPdwOjZbk/image_thumb%5B6%5D.png?imgmax=800" width="632" height="285" /></a> </p>  <p>Ótimo, isso já é metade do caminho, mas ainda falta carregar a extensão externa que está no projeto MEF.Extension. Como isso será feito?</p>  <p>Coloquei um botão na tela que fará o download do xap gerado pelo projeto MEF.Extension e o adicionará ao catalogo do MEF para que ele saiba onde procurar mas para que isso fosse possível foram necessários 2 passos:</p>  <ol>   <li>Alterarar o catalogo padrão do MEF para um tipo de catalogo que permita modificações dinâmicas em runtime. </li>    <li>Recompilar e utilizar uma dll do Toolkit do Silverlight 4 que contém esse novo tipo catalogo além de uma classe que já faz o trabalho de executar o download do xap, ler seu manifesto, carregar suas dlls na memória e adicioná-las ao catalogo. </li> </ol>  <p>Na verdade nós começamos pelo passo 2, baixando o <a title="código fonte do Toolkit para o Silverlight 4 no Codeplex" href="http://silverlight.codeplex.com/SourceControl/list/changesets">código fonte do Toolkit para o Silverlight 4</a>. Depois criamos na nossa solution um projeto class library em Silverlight 3 chamado “System.ComponentModel.Composition.Packaging.Toolkit” com as mesmas propriedades do original que está no código fonte que baixamos e copiamos os arquivos das classes de um projeto para o outro.</p>  <p>Depois vamos para o passo 1, onde temos que fazer uma alteração, preferencialmente na inicialização da aplicação, criando o novo catalogo e preparando o MEF para aceitar módulos externos em runtime. Abaixo temos as aterações que foram feitas no arquivo App.xaml.cs.</p>  <p><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="Alterações na classe App.xaml.ca" border="0" alt="Alterações na classe App.xaml.ca" src="http://lh5.ggpht.com/_33jXBude3Pw/S1IGyKW65vI/AAAAAAAAAqI/XG1PmK7_Kbs/image%5B43%5D.png?imgmax=800" width="630" height="563" /> </p>  <p>Foi criada uma propriedade estática Catalog (que será utilizada mais adiante) e um método InitializeContainer() que registra o novo catalogo para ser utilizado pelo MEF.</p>  <p>Na linha 37 o xap atual é adicionado ao catalogo. Isso garante que tudo que estiver no xap da aplicação já funcione por padrão. Na linha 42 esse novo catalogo é registrado para ser utilizado pelo MEF. A linha 40, que está comentada, é de um exemplo em Silverlight 4 e não funciona (nem pareceu ser necessária) em Silverlight 3.</p>  <p>Na linha 46 adicionamos a chamada ao novo método no Startup da aplicação, antes de instanciar a tela principal.</p>  <p>A única coisa que falta agora é fazer o download do xap que contém a extensão e adicioná-lo ao catalogo. Para isso estou utilizando o evento de click do botão que está na tela:</p>  <p> <img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="Código para download da extensão" border="0" alt="Código para download da extensão" src="http://lh5.ggpht.com/_33jXBude3Pw/S1IGy9tX5SI/AAAAAAAAAqM/PUKMwKsaPXw/image%5B50%5D.png?imgmax=800" width="597" height="295" /> </p>  <p>No click do botão é feito o seguinte:</p>  <ul>   <li>É criada uma nova Uri com o endereço de onde será feito o download do xap com a extensão. Estou usando UriKind.Relative pois o xap está no mesmo diretório onde está o xap da aplicação principal. </li>    <li>É chamado o método estático Package.DownloadPackageAsync passando a Uri do xap e uma função lambda que será responsável por adicionar o novo pacote no catalogo. </li> </ul>  <p>O que o DownloadPackageAsync faz é executar o download do xap, ler seu manifesto e carregar todas suas dlls na memória. No final ele está executando a função lambda que passamos, que adiciona esse pacote xap no catalogo.</p>  <p>Esse novo tipo de catalogo então notifica o MEF de que há um novo pacote disponível e o MEF recompõe a aplicação automaticamente (não é necessário pedir par ao MEF “satifazer os imports” novamente). É por isso que no atributo ImportMany da propriedade Servicos está sendo passado o parâmetro AllowRecomposition=true. Sem ele a recomposição automática não aconteceria.</p>  <p>Se executarmos a aplicação novamente agora, continuarão aparecendo apenas 3 serviços no ListBox, mas ao clicar no botão um quarto serviço aparece.</p>  <p><a href="http://lh5.ggpht.com/_33jXBude3Pw/S1IGzvb4O8I/AAAAAAAAAqQ/6hv8sojEG3g/s1600-h/image%5B61%5D.png" target="_blank"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="Aplicação rodando com extensões internas e externas" border="0" alt="Aplicação rodando com extensões internas e externas" src="http://lh6.ggpht.com/_33jXBude3Pw/S1IG1NxHlCI/AAAAAAAAAqU/kbhCLmldq2M/image_thumb%5B5%5D.png?imgmax=800" width="632" height="285" /></a> </p>  <p>A aplicação agora é extensível e se recompõe automaticamente quando uma nova extensão é baixada. E o mais importante: <strong>Não tivemos que escrever nenhum código para atualizar a tela novamente! </strong></p>  <h4>Mas espere um momento, você não mostrou como a extensão foi feita!</h4>  <p>Sim, eu sei disso, mas não tem segredo. É que eu queria mostrar algumas dicas para criar as extensões.</p>  <p>Vocês devem ter notado que a extensão é um xap. Para fazer isso , adicione um novo projeto Silverlight Application na solution e remova todo o seu código (App.xaml, App.xaml.cs, MainPage.xaml, MainPage.xaml.cs). Depois trate ele normalmente como uma class library. Não se esqueça de vinculá-lo à sua aplicação web de testes para que ele seja atualizado na pasta ClientBin sempre que compilar.</p>  <p><a href="http://lh3.ggpht.com/_33jXBude3Pw/S1IG1WIPVnI/AAAAAAAAAqY/SZDMxZ6wI3Y/s1600-h/image%5B78%5D.png" target="_blank"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="Vinculando projetos Silverlight na aplicação web" border="0" alt="Vinculando projetos Silverlight na aplicação web" src="http://lh6.ggpht.com/_33jXBude3Pw/S1IG2NYPFUI/AAAAAAAAAqc/auhQIFNj2DE/image_thumb%5B11%5D.png?imgmax=800" width="632" height="319" /></a> </p>  <p>Esse projeto tem que fazer referencia à dll que contém os contratos (MEF.Lib) que por consequencia faz referência a dll principal do MEF. Se você simplesmente gerar o xap ele ficará quase do tamanho da aplicação principal pois conterá as 2 dlls, mas elas não precisam estar nesse xap pois já estarão no xap da aplicação então você deve marcar a opção “Copy Local” da MEF.Lib para falso.</p>  <p> <a href="http://lh6.ggpht.com/_33jXBude3Pw/S1IG2vBhmaI/AAAAAAAAAqg/zAUgJRri1gQ/s1600-h/image%5B72%5D.png" target="_blank"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="Diminuindo o tamanho da extensão" border="0" alt="Diminuindo o tamanho da extensão" src="http://lh6.ggpht.com/_33jXBude3Pw/S1IG3GBD7sI/AAAAAAAAAqk/JP8JCXykbmY/image_thumb%5B8%5D.png?imgmax=800" width="632" height="296" /></a> </p>  <h4>O que falta então?</h4>  <p>Em uma palavra? Cache. Do jeito que está se eu fechar e abrir novamente a aplicação, a extensão que havia baixado antes não estará mais lá, mas isso é fácil de resolver. Basta salvar a extensão no IsolatedStorage e procurar por todas as extensões que foram salvas durante a criação do container. Eu criaria um diretorio addins salvaria os xaps lá. Depois basta procurar todos os xaps que estiverem nesse diretório, carregá-los na memória e adicioná-los no catálogo.</p>  <h4>Conclusão</h4>  <p>Esse post todo foi apenas para mostrar como é simples usar MEF e como isso pode ajudar. Você não precisa mais criar todas as funcionalidades da sua aplicação de uma vez ou sozinho. Crie pontos de extensão e vá incluindo as funcionalidades em pacotes ou deixe que a comunidade crie extensões para seu aplicativo.</p>  <p>Vale lembrar que sempre que você adiciona referencias que não estão no runtime aos seus projetos, o tamanho do xap final aumenta. As dlls do MEF aumentam o tamanho do xap em 96KB. </p>  <p>O MEF é muito mais do que o que coloquei aqui hoje, por isso tem esse tamanho. Eu pesei os prós e contras e para essa aplicação vale muito a pena. </p>  <p>Abaixo tem um link para o código fonte do projeto mostrado aqui. Happy MEFing!</p> <iframe style="padding-bottom: 0px; background-color: #fcfcfc; padding-left: 0px; width: 98px; padding-right: 0px; height: 115px; padding-top: 0px" title="Preview" marginheight="0" src="http://cid-c15a3c05f395fee5.skydrive.live.com/embedicon.aspx/Exemplos%20Blog/MEF-SL3.zip" frameborder="0" marginwidth="0" scrolling="no"></iframe>  
