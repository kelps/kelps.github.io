---
layout: blogger
title: Silverlight 4 - Novo xaml parser e suporte namespaces xml
date: 2010-04-20T22:20:00.0010000-03:00
permalink: /:year/:month/:slug:output_ext
tags: [Dicas, Silverlight, Silverlight 4]
---
<p>O <a href="http://www.silverlight.net/getstarted/">Silverlight 4</a> foi lançado na semana passada é já existe uma tonelada de posts com informações a respeito das novidades. Eu estava lendo um <a href="http://blogs.msdn.com/silverlight_sdk/archive/2010/03/24/a-one-stop-shopping-xaml-namespace-for-silverlight-client-sdk-controls.aspx">post do blog do Silverlight SDK</a> e encontrei uma novidade interessante sobre a qual não se está falando muito. O parser de xaml do Silverlight 4 agora respeita corretamente as definições de namespace xml. Isso tem várias implicações:</p>  <ul>   <li>Agora o namespace padrão dos seus arquivos xml não precisa mais ser “<a title="http://schemas.microsoft.com/winfx/2006/xaml/presentation" href="http://schemas.microsoft.com/winfx/2006/xaml/presentation">http://schemas.microsoft.com/winfx/2006/xaml/presentation</a>”. Você pode mudar se for útil/necessário para sua aplicação (por exemplo, se você estiver gerando xaml dinamicamente utilizando apenas controles customizados). </li>    <li>Com esse suporte, agora é possível criar os seus próprios namespaces, agrupando vários namespaces da sua apliação ou mesmo de diversos assemblies distintos. </li>    <li>Frameworks como o Silverlight Toolkit e o SDK já estão tirando proveito disso, definindo seus próprios namespaces para simplificar sua utilização e eliminar a necessidade de ter que conhecer toda a estrutura desses projetos para saber onde estão os controles que queremos usar. </li> </ul>  <p>Ou seja, agora é possível ter acesso a todos os controles do Silverlight Toolkit ou SDK acrescentando apenas 2 namespaces na sua tela, como abaixo (mas lembre-se que ainda é necessário fazer referencias as dlls):</p> <code>xmlns:toolkit=”http://schemas.microsoft.com/winfx/2006/xaml/presentation/toolkit xmlns:sdk=”http://schemas.microsoft.com/winfx/2006/xaml/presentation/sdk </code>  <p>Tudo isso é muito interessante e muito legal mas o que me deixou intrigado é que eu não estava conseguindo encontrar informações em nenhum lugar que explicassem como é que eu poderia fazer meus frameworks e apis tirarem proveito desses recursos. Cheguei até a achar por um momento que esses novos namespaces estivesses fixos no Silverlight 4, mas como não era esse o discurso, tinha que have um jeito de implementarmos isso em nossas aplicações. </p>  <p>Foi então que eu tive a idéia de seguir um conselho que o <a href="http://www.hanselman.com">Scott Hanselman</a> vive repetindo quase como um mantra que é “ler código alheio para se tornar um programador melhor”. Tendo isso em mente eu fui ao codeplex e comecei a fuçar no código fonte do Silverlight Toolkit, até que <a title="Código fonte do Silverlight Tookit no Codeplex, mostrando onde são definidos alguns namespaces xml" href="http://silverlight.codeplex.com/SourceControl/changeset/view/47051#974667">achei o que estava procurando</a>. Para que você possa tirar proveito desse recurso em suas próprias aplicações e frameworks, basta marcar o assembly com os atributos XmlnsPrefix e XmlnsDefinition, como demonstrado abaixo:</p> <code>[assembly: XmlnsPrefix(http://schemas.wf.com.br/sdk, "wf")] [assembly: XmlnsDefinition(http://schemas.wf.com.br/sdk, "WF.Silverlight")] [assembly: XmlnsDefinition(http://schemas.wf.com.br/sdk, "WF.Silverlight.Controles")]</code>   <p>O lugar ideal para definir esses atributos é no arquivo AssemblyInfo do projeto. Para poder utilizar esses atributos é necessário referenciar o namespace System.Windows.Markup nas instruções de using no top da página. </p>  <p>O atributo XmlnsPrefix serve para criar um namespace e pré-definir qual será o seu prefixo quando um controle for adicionado diretamente pelo Visual Studio ou Expression Blend. Geralmente haverá apenas 1 atributo desse por projeto.</p>  <p>O atributo XmlnsDefinition é o responsável por vincular um namespace xml com um namespace do assembly. Esse atributo pode ser adicionado ao assembly quantas vezes for necessário. Geralmente haverá um atributo desse para cada namespace do assembly que contenha controles ou elementos que se deseja disponibilizar no xaml.</p>  <p>Uma coisa muito interessante que eu descobri é que os namespaces que você criar aparecem no intellisense do Visual Studio 2010, como pode ser visto abaixo:</p>  <p> <img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="http://lh3.ggpht.com/_33jXBude3Pw/S85S9XsPgVI/AAAAAAAAAzg/ZPteFYkqgug/image%5B7%5D.png?imgmax=800" width="621" height="363" /> </p>  <p>Espero que essas dicas tenham sido úteis. Eu sei que vou tirar proveito dessa nova funcionalidade nos meus próximos projetos.</p>  <p><strong>Update 30/04/2010</strong> : Encontrei um problema na implementação que demonstrei aqui. Devido a uma limitação do compilador do Silverlight, não é possível atribuir a propriedade x:Name a um controle definido por meio do novo xmlns se esse controle fizer parte do mesmo assembly em que está sendo utilizado. Ficou meio confuso, então vou tentar dar um exemplo:</p>  <p>Temos uma solution com um projeto. Esse projeto tem o seguinte xmlns:  xmlns:my=http://schema.minhaempres.silverlight e um controle chamado ControleA que está sendo “coberto” por esse xmlns. Se eu criar um ControleB nesse projeto, definir o uso do namespace “my” e utilizar o ControleA com a seguinte sintax, vai funcionar : <my:ControleA />. Se eu tentar atribuir a propriedade x:Name no meu ControleA, não vai mais funcionar. O problema é apenas com a propriedade x:Name e apenas se ambos os controles estiverem no mesmo assembly. Muitas vezes a gente consegue criar telas inteiras sem precisar dar nomes aos campos, principalmente graças ao uso de data binding, mas se for necessário fazer alguma animação, manipular o controle via code behind ou utilizar em algum TemplatePart de outro controle, tem que ter name.</p>  <p>Agora a boa notícia. Como esse erro só acontece se os 2 controles em questão estiverem no mesmo assembly, o workaround é simples, basta utilizar a declaração convencional de xmlns que usamos normalmente, onde dizemos o nome do assembly e namespace da classe. </p>  
