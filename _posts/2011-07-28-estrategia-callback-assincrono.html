---
layout: blogger
title: Estratégia para lidar com callbacks assíncronos em Silverlight
date: 2011-07-28T18:19:00.0000000-03:00
permalink: /:year/:month/:slug:output_ext
tags: [Tutorial, Silverlight, Código, Silverlight 4]
---
<p>Recentemente, conversando com alguns desenvolvedores no trabalho e verificando algumas perguntas publicadas nos fóruns do MSDN, eu notei que ainda há uma dificuldade muito grande tanto de compreensão quanto de implementação para trabalhar com métodos assincronos. Isso se torna um problema particularmente importante em aplicações Silverlight pois todas as chamadas a web services, RIA services, web requests, etc são obrigatoriamente feitos de forma assincrona, não havendo opções para executar essas mesmas operações da forma sincrona e linear à qual a maioria dos desenvolvedores está acostumada.</p> <p>Acontece que desenvolvimento assincrono não é difícil e, depois que você aprende e se acostuma, você acaba percebendo que suas aplicações passam a funcionar muito melhor. Sim, não vou argumentar aqui contra o fato de que é necessário se acostumar e que começo seja realmente algo estranho, mas posso garantir que demora pouco tempo para se acostumar e os benefícios são muitos.</p> <p>Há muitas abordagens e estratégias possíveis para desenvolvimento assíncrono e eu vou apresentar aqui uma delas que é bem simples e que eu usei em praticamente todos os projetos Silverlight em dos quais participei. Essa abordagem não envolve o uso de nenhum framework ou biblioteca externa e pode ser utilizada tranquilamente também em projetos que não sejam Silverlight.</p> <p>Digamos que você precisa obter o html de uma página web por algum motivo. Uma forma de fazer isso seria criando uma nova instância de WebClient, assinando o evento DownloadStringCompleted e depois chamando o método DownloadString passando a url. Ok, não é difícil, mas é um código repetitivo que poderia facilmente ser reaproveitado ao invés de ser copiado por toda sua aplicação em todo lugar onde você precisar fazer download de uma página. O que eu costumo fazer para esse tipo de chamada é criar um método estático em uma classe utilitária e simplesmente chamar esse método passando, nesse caso, minha url e um ponteiro de callback. É mais fácil mostrar:</p><pre style="line-height: normal; font-family: ; background: white; color: "><font face="Consolas"><span style="color: "><font color="#0000ff"><font style="font-size: 9.8pt">public</font></font></span><font style="font-size: 9.8pt"><font color="#000000"> </font><span style="color: "><font color="#0000ff">static</font></span><font color="#000000"> </font><span style="color: "><font color="#0000ff">void</font></span><font color="#000000"> HttpGet(</font><span style="color: "><font color="#0000ff">string</font></span><font color="#000000"> url, Action<</font><span style="color: "><font color="#0000ff">string</font></span><font color="#000000">, </font><span style="color: "><font color="#2b91af">Exception</font></span></font></font><font style="font-size: 9.8pt"><font face="Consolas"><font color="#000000">> callback) {<br>    </font><span style="color: "><font color="#0000ff">if</font></span><font color="#000000"> (!</font><span style="color: "><font color="#0000ff">string</font></span></font><font face="Consolas"><font color="#000000">.IsNullOrWhiteSpace(url)) {<br>        </font><span style="color: "><font color="#0000ff">var</font></span><font color="#000000"> client = </font><span style="color: "><font color="#0000ff">new</font></span><font color="#000000"> </font><span style="color: "><font color="#2b91af">WebClient</font></span></font><font face="Consolas"><font color="#000000">();<br>        client.DownloadStringCompleted += (sender, e) => {<br>            </font><span style="color: "><font color="#0000ff">if</font></span><font color="#000000"> (callback != </font><span style="color: "><font color="#0000ff">null</font></span></font></font><font face="Consolas"><font style="font-size: 9.8pt"><font color="#000000">) {<br>                callback(e.Result, e.Error);<br>            }<br>        };<br>        client.DownloadStringAsync(</font><span style="color: "><font color="#0000ff">new</font></span><font color="#000000"> </font><span style="color: "><font color="#2b91af">Uri</font></span><font color="#000000">(url));<br>    }<br>}</font></font></font></pre><br /><p>Quais são as vantagens desse método:</p><br /><ul><br /><li>para executá-lo não é necessário instanciar nenhuma classe <br /><li>é facil de reutilizar <br /><li>permite que a lógica da minha aplicação fique um pouco mais simples, já que não me obriga a assinar nenhum evento no meu código</li></ul><br /><p>Para executar esse método, eu posso usar 2 abordagens.</p><br /><p>Abordagem 1 – Delegar o retorno para outro método. Nessa abordagem eu chamo o método HttpGet passando a url desejada e o ponteiro de um método que será executado quando o request for concluído.</p><pre style="line-height: normal; font-family: ; background: white; color: "><font face="Consolas"><span style="color: "><font color="#0000ff"><font style="font-size: 9.8pt">private</font></font></span><font style="font-size: 9.8pt"><font color="#000000"> </font><span style="color: "><font color="#0000ff">void</font></span></font></font><font style="font-size: 9.8pt"><font face="Consolas"><font color="#000000"> LoadData() {<br>    HttpGet(</font><span style="color: "><font color="#a31515">"http://kelps.net"</font></span></font><font face="Consolas"><font color="#000000">, DataLoaded);<br>}<br> </font><br><span style="color: "><font color="#0000ff">private</font></span><font color="#000000"> </font><span style="color: "><font color="#0000ff">void</font></span><font color="#000000"> DataLoaded(</font><span style="color: "><font color="#0000ff">string</font></span><font color="#000000"> data, </font><span style="color: "><font color="#2b91af">Exception</font></span></font><font face="Consolas"><font color="#000000"> error) {<br>    </font><span style="color: "><font color="#0000ff">if</font></span><font color="#000000"> (error == </font><span style="color: "><font color="#0000ff">null</font></span></font></font><font face="Consolas"><font style="font-size: 9.8pt"><font color="#000000">) {<br>        </font><span style="color: "><font color="#008000">//utiliza os dados retornados na variável "data"</font></span><br><font color="#000000">    }<br>}</font></font></font></pre><br /><p>Abordagem 2 – Utilizar uma expressão lambda para criar um método anônimo inline no meu código, ao invés de criar uma função separada apenas para processar os dados retornados.</p><pre style="line-height: normal; font-family: ; background: white; color: "><font face="Consolas"><font color="#000000"><font style="font-size: 9.8pt">HttpGet(</font></font><font style="font-size: 9.8pt"><span style="color: "><font color="#a31515">"http://twitter.com/kelps"</font></span></font></font><font style="font-size: 9.8pt"><font face="Consolas"><font color="#000000">, (data, error) => {<br>    </font><span style="color: "><font color="#0000ff">if</font></span><font color="#000000"> (error == </font><span style="color: "><font color="#0000ff">null</font></span></font></font><font face="Consolas"><font style="font-size: 9.8pt"><font color="#000000">) {<br>        </font><span style="color: "><font color="#008000">//utiliza os dados retornados na variável "data"</font></span><br><font color="#000000">    }<br>});</font></font></font></pre><br /><p>A única diferença de funcionamento entre as 2 abordagens acima é que na segunda seria possível utilizar variáveis que estiverem no mesmo escopo da chamada que está sendo feita, ao passo que na primeira seria necessário que essas variáveis fossem globais da classe para que isso funcione. Nos projetos em que trabalho eu costumo utilizar ambas as abordagens, de acordo com o que faz mais sentido em cada situação. Expressões lambda são bem concisas e compactas, mas são claras para qualquer desenvolvedor. </p><br /><p>Este foi apenas um pequeno exemplo de como trabalhar com chamadas assincronas sem ficar se perdendo com assinaturas e liberação de eventos. Há outras formas mais complexas e robustas de lidar com isso mas a minha intenção hoje era simplesmente mostrar como dá pra trabalhar de forma simples com código assíncrono, mesmo sem utilizar nenhuma biblioteca externa.</p>  
