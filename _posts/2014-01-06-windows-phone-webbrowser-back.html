---
layout: blogger
title: Integrando o botão voltar do Windows Phone com o controle WebBrowser
date: 2014-01-06T11:54:00.0000000-02:00
permalink: /:year/:month/:slug:output_ext
tags: [Windows Phone 8, Windows Phone 7, Windows Phone]
---
<p>Recentemente trabalhei em um projeto para Windows Phone onde a aplicação continha um mix de telas xaml e webviews (páginas web hospedadas nos servidores da empresa). O uso de webviews era um requisito da empresa pois as funcionalidades existentes nessas páginas não estavam disponíveis por meio de apis e tais apis não serão disponibilizadas no futuro próximo.</p> <p>Para dar uma boa experiência para os usuários da aplicação, queríamos que o botão voltar do aparelho também afetasse a navegação do webview, fazendo com que o usuário não perceba que estã em uma webview e a aplicação inteira tenha um comportamento consistente. Já vi várias aplicações no Windows Phone que usam webviews sem fazer isso e a experiência é péssima pois você está no webview, usa o voltar do aparelho para tentar ir para a página anterior e acaba saindo da navegação do webview por completo e indo para a tela anterior ao webview (o aplicativo Audible é um exemplo desse comportamento ruim).</p> <p>Para fazer essa integração com o botão voltar não basta assinar o evento do voltar do telefone e chamar o voltar do webbrowser pois é necessário saber se o webbrowser ainda tem para onde voltar e temos que tomar cuidado para não entrar em um looping de backstack (navegando entre páginas que foram chamadas usando o back, fazendo com que a pilha nunca acabe).</p> <p>Para realizar isso de forma correta, precisamos controlar a navegação do webview. Esse controle consiste em criar e manter uma lista contendo as urls navegadas e um método que decide se o webview ainda pode voltar. A única limitação da solução proposta neste post é que ela só funciona corretamente para casos onde a navegação entre as páginas em modo webview passa parametros via url (querystring) e não via post. Se alguma página for navegada via post, o back pode não vai voltar para ela como o usuário espera. No caso da aplicação que eu estava trabalhando isso não seria um problema, mas se fosse seria necessária uma solução bem mais complexa que envolveria injeção de javascript nas páginas do webview.</p> <p>O controle da navegação é feito assinando o evento “Navigated” do controle WebBrowser. Abaixo segue o código comentado usado nesse event handler.</p> <p><font color="#000000"><font face="Courier New"><font color="#0000ff">int</font> GoingBack = 0; <font color="#008000">//contador indicando se está voltando</font> <br><font color="#008080">Uri</font> CurrentPage = <font color="#0000ff">null</font>;<br><font color="#008080">Stack</font><<font color="#008080">Uri</font>> NavigationStack = <font color="#0000ff">new</font> <font color="#008080">Stack</font><<font color="#008080">Uri</font>>(); <font color="#008000">//pilha de navegação</font></font></font><font color="#008000"> </font> <p><font color="#000000"><font face="Courier New"><font color="#008000">/// <summary><br>/// conta quantas páginas foram navegadas para saber se pode voltar.<br>/// ignora a contagem quando a navegação foi feita usando back<br>/// </summary></font><br><font color="#0000ff">void</font> webview_Navigated(<font color="#0000ff">object</font> sender, <font color="#008080">NavigationEventArgs</font> e) {<br>    <font color="#0000ff">lock</font> (<font color="#0000ff">this</font>) {<br>        <font color="#0000ff">if</font> (GoingBack > 0) {<br>            GoingBack--;<br>        } <font color="#0000ff">else</font> {<br>            <font color="#0000ff">if</font> (CurrentPage != <font color="#0000ff">null</font>) {<br>                NavigationStack.Push(CurrentPage);<font color="#008000">//acrescenta a página de onde está saindo na pilha de navegação</font><br>            }<br>        }<br>        CurrentPage = e.Uri;<br>    }<br>}</font></font>  <p>O NavigationEventArgs do evento acima tem uma propriedade chamada NavigationMode que teoricamente indicaria se a navegação é do tipo New, Back, Forward ou Refresh, mas não está sendo usada pois ela não indicou os valores corretos nos meus testes, mesmo quando eu estava usando “history.back();” ou “history.go(-1);” via javascript injection no webview. Por isso foi necessário controlar se está sendo feita navegação de back e quais páginas estão na pilha.</p> <p>O segundo método usado para esse processo é o responsável por tentar efetuar a navegação do webview para a página anterior e informar se conseguiu.</p> <p><font color="#000000"><font face="Courier New"><font color="#008000">/// <summary><br>/// Tenta navegar o browser para a página anterior. Se conseguir retorna true, se não houver página anterior ou der erro, retorna false.<br>/// </summary><br></font><font color="#0000ff">bool</font> TryGoBack() {<br>    <font color="#0000ff">lock</font> (<font color="#0000ff">this</font>) {<br>        <font color="#0000ff">if</font> (NavigationStack.Count > 0) {<br>            <font color="#0000ff">try</font> {<br>                GoingBack++; </font><font face="Courier New"><font color="#008000">//incrementa o contador de navegação voltando<br></font>                webview.Navigate(NavigationStack.Pop()); <font color="#008000">//remove a última página navegada da pilha e navega para ela</font><br>                <font color="#0000ff">return true</font>;<br>            } <font color="#0000ff">catch</font> { }<br>        }<br>    }<br>    <font color="#0000ff">return false</font>;<br>}</font></font>  <p>A última parte do processo todo é assinar o evento do botão back do telefone usando o código abaixo:</p> <p><font color="#000000"><font face="Courier New"><font color="#0000ff">protected override void</font> OnBackKeyPress(System.ComponentModel.<font color="#008080">CancelEventArgs</font> e) {<br>    e.Cancel = TryGoBack();<br>    <font color="#0000ff">if</font> (!e.Cancel) <font color="#0000ff">base</font>.OnBackKeyPress(e); <br>}</font></font>  <p>Se sua aplicação tiver mais de um lugar que utilize webviews, você pode criar um controle para encapsular o webbrowser e os 2 primeiros métodos, mas o evento do botão voltar deverá ser assinado em cada página que usar esse controle, pois não é possível assinar o evento do voltar a partir de controle. Não esqueça de fazer o método TryGoBack ser public se encapsular o controle, para poder chamar a partir da página.</p> <p>DISCLAIMER: Este código é disponibilizado “as is”, e atende às necessidades descritas acima, mas deve ser bem testado para garantir que funcionará da forma desejada em outras aplicações. Este código funciona tanto para Windows Phone 7 como 8.</p>  
